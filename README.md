# JVM. Организация памяти, сборщики мусора.

## JAVA. Начало...
Сначала был **текст программы** JAVA — это набор текстовых файлов с расширением .java, написанных в корректном синтаксисе Java.

Затем происходит обработка текста программы компилятором (javac - Java Compiler). Результатом работы javac файлы типа .class (байт-код).
Они и передаются на исполнение JVM.
<blockquote>JVM не существует. Это просто спецификация, у которой есть различные реализации под разные операционные системы и потребности</blockquote>

## Код для исследования.
```java
public class JvmComprehension {

    public static void main(String[] args) {
        int i = 1;                      // 1
        Object o = new Object();        // 2
        Integer ii = 2;                 // 3
        printAll(o, i, ii);             // 4
        System.out.println("finished"); // 7
    }

    private static void printAll(Object o, int i, Integer ii) {
        Integer uselessVar = 700;                   // 5
        System.out.println(o.toString() + i + ii);  // 6
    }
}
```
## Подсистема загрузчиков классов
### СlassLoader
СlassLoader - последовательно опрашивает загрузчиков входящих в его состав:
* Bootstrap ClassLoader 
* Platform  ClassLoader
* Application ClassLoader
* 
Это три основных загрузчика в JVM. Еще может быть **пользовательский** ClassLoader

На этом этапе происходит поиск запрошенного класса среди загруженных ранее, получение байт-кода для загрузки, создание экземпляра класса Class, загрузка родительских классов. Если родительские классы и интерфейсы не были загружены, то и рассматриваемый класс считается не загруженным и выбрасывается ошибка ClassNotFoundException.

Следующий этап - Linking (связывание), включает в себя:
* Verify, происходит проверка корректности полученного байт-кода.
* Prepare, выделение оперативной памяти под статические поля и инициализация их значениями по умолчанию (при этом явная инициализация, если она есть, происходит уже на этапе инициализации).
* Resolve, разрешение символьных ссылок типов, полей и методов.
## Области памяти (стэк (и его фреймы), heap). Сборщик мусора.
Найденный на предыдущем этапе класс JvmComprehension (в рассматриваемом примере) загружается в Metaspace. 
* В области памяти Stack создается фрейм main в нем создается переменная **int i** (1) и инициализируется значением = 1.
* В *heap* (куча) выделяется место для экземпляра класса  **Object** , а затем во фрейме main размещается ссылка этот на объект **о** (2).
* В куче выделяется место для объекта класса **Integer** и ссылка на него присваивается в качестве значения переменной **ii** (3).
* Далее вызывается метод *printAll()*. Соответственно для него в Stack создается новый фрейм(4), в нем создается переменная **int i = 1** и ссылки на объекты **o** и **ii**.
* Создается переменная типа **Integer** *uselessVar* в стеке и ссылка на объект **Integer** в heap во фрейме *printAll()*(5).
* Загружается класс System. Вызывается метод, и создается фрейм, *println()* объекта out класса System. В этот метод передаются ссылки на объекты **o** и **ii**, и переменная **i**(6).
  После выполнения *printALl()* удаляется фрейм в стеке вместе с задействованными в нем переменными и объектами. Также "сборщики мусора" удаляют фрейм *println()*. Из кучи удаляются ссылки на удаленные экземпляры объектов. 
* Снова загружается класс System (7). Создается фрейм *println()*. После завершения печати в консоль опять наступает черед "сборщика мусора" и фрейм *println()* удаляется. После завершения работы main из стека удаляются все созданные для класса объекты, переменные и наконец сам фрейм main. В куче удаляются все созданные объекты.    